---
name: Real-time Updates
status: open
created: 2026-01-30T08:03:38Z
updated: 2026-01-30T08:03:38Z
github: [To be updated during sync]
depends_on: [003, 005]
parallel: false
conflicts_with: []
---

# Task: Real-time Updates

## Description

Implement real-time request updates using WebSocket connections with automatic reconnection, fallback to HTTP polling, and connection status indicators. This enables the core "live webhook viewer" functionality, showing incoming requests instantly without manual refresh.

**Scope:**
- Establish WebSocket connection per endpoint
- Handle incoming request messages and update UI
- Implement auto-reconnect with exponential backoff
- Add connection status indicator (connected/disconnected)
- Implement HTTP polling fallback when WebSocket unavailable
- Add visual feedback for new requests (pulse animation)
- Handle multiple endpoint subscriptions

## Acceptance Criteria

- [ ] WebSocket connects successfully to backend on endpoint selection
- [ ] New requests appear in list immediately without refresh
- [ ] Auto-reconnect works after connection loss (tested by killing connection)
- [ ] Exponential backoff respects limits (1s, 2s, 4s, 8s, max 30s)
- [ ] Connection indicator shows "Connected" (green) or "Reconnecting..." (yellow)
- [ ] HTTP polling fallback activates if WebSocket fails after 3 attempts
- [ ] New request has pulse/highlight animation for 2 seconds
- [ ] Multiple endpoints can be subscribed simultaneously
- [ ] Switching endpoints disconnects old WebSocket and connects new one
- [ ] WebSocket disconnects cleanly on unmount
- [ ] No duplicate requests in the list

## Technical Details

### 1. Enhanced WebSocket Client (`lib/websocket.ts`)

Improve the WebSocket client from Task 003 with better lifecycle management:

```typescript
export type ConnectionStatus = 'connecting' | 'connected' | 'disconnecting' | 'disconnected' | 'error';

export interface WebSocketConfig {
  url: string;
  maxReconnectAttempts?: number;
  maxReconnectDelay?: number;
  onMessage: (message: WebSocketMessage) => void;
  onStatusChange?: (status: ConnectionStatus) => void;
}

export class WebSocketClient {
  private ws: WebSocket | null = null;
  private reconnectAttempts = 0;
  private reconnectTimer?: number;
  private status: ConnectionStatus = 'disconnected';
  private config: WebSocketConfig;

  constructor(config: WebSocketConfig) {
    this.config = {
      maxReconnectAttempts: 10,
      maxReconnectDelay: 30000,
      ...config,
    };
  }

  connect() {
    this.updateStatus('connecting');

    try {
      this.ws = new WebSocket(this.config.url);

      this.ws.onopen = () => {
        this.reconnectAttempts = 0;
        this.updateStatus('connected');
      };

      this.ws.onmessage = (event) => {
        try {
          const message: WebSocketMessage = JSON.parse(event.data);
          this.config.onMessage(message);
        } catch (err) {
          console.error('Failed to parse WebSocket message:', err);
        }
      };

      this.ws.onerror = (error) => {
        console.error('WebSocket error:', error);
        this.updateStatus('error');
      };

      this.ws.onclose = () => {
        this.updateStatus('disconnected');
        this.attemptReconnect();
      };
    } catch (err) {
      console.error('Failed to create WebSocket:', err);
      this.updateStatus('error');
      this.attemptReconnect();
    }
  }

  private attemptReconnect() {
    const maxAttempts = this.config.maxReconnectAttempts || 10;
    if (this.reconnectAttempts >= maxAttempts) {
      console.warn('Max reconnect attempts reached. Giving up.');
      return;
    }

    const delay = Math.min(
      1000 * Math.pow(2, this.reconnectAttempts),
      this.config.maxReconnectDelay || 30000
    );

    this.reconnectTimer = window.setTimeout(() => {
      this.reconnectAttempts++;
      this.connect();
    }, delay);
  }

  disconnect() {
    this.updateStatus('disconnecting');

    if (this.reconnectTimer) {
      clearTimeout(this.reconnectTimer);
      this.reconnectTimer = undefined;
    }

    if (this.ws) {
      this.ws.close();
      this.ws = null;
    }

    this.updateStatus('disconnected');
    this.reconnectAttempts = 0;
  }

  send(data: unknown) {
    if (this.ws?.readyState === WebSocket.OPEN) {
      this.ws.send(JSON.stringify(data));
      return true;
    }
    return false;
  }

  private updateStatus(status: ConnectionStatus) {
    this.status = status;
    this.config.onStatusChange?.(status);
  }

  getStatus(): ConnectionStatus {
    return this.status;
  }
}
```

### 2. Enhanced useWebSocket Hook (`hooks/useWebSocket.ts`)

```typescript
export function useWebSocket(endpointId: string | null) {
  const [status, setStatus] = useState<ConnectionStatus>('disconnected');
  const [lastMessage, setLastMessage] = useState<WebSocketMessage | null>(null);
  const [useFallback, setUseFallback] = useState(false);
  const clientRef = useRef<WebSocketClient | null>(null);
  const fallbackTimerRef = useRef<number>();

  useEffect(() => {
    if (!endpointId) return;

    // WebSocket URL construction
    const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
    const wsUrl = `${wsProtocol}//${location.host}/api/ws/${endpointId}`;

    let failedAttempts = 0;

    const client = new WebSocketClient({
      url: wsUrl,
      onMessage: (message) => {
        setLastMessage(message);
        failedAttempts = 0; // Reset on successful message
        setUseFallback(false);
      },
      onStatusChange: (newStatus) => {
        setStatus(newStatus);

        // Activate HTTP polling fallback after 3 failed attempts
        if (newStatus === 'error') {
          failedAttempts++;
          if (failedAttempts >= 3) {
            setUseFallback(true);
            client.disconnect();
          }
        }
      },
    });

    client.connect();
    clientRef.current = client;

    return () => {
      client.disconnect();
      if (fallbackTimerRef.current) {
        clearInterval(fallbackTimerRef.current);
      }
    };
  }, [endpointId]);

  // HTTP polling fallback
  useEffect(() => {
    if (!useFallback || !endpointId) return;

    const pollInterval = 5000; // Poll every 5 seconds
    fallbackTimerRef.current = window.setInterval(async () => {
      try {
        const requests = await api.requests.list(endpointId);
        // Emit the latest request as a message
        if (requests.length > 0) {
          setLastMessage({
            type: 'new_request',
            data: requests[0],
          });
        }
      } catch (err) {
        console.error('HTTP polling failed:', err);
      }
    }, pollInterval);

    return () => {
      if (fallbackTimerRef.current) {
        clearInterval(fallbackTimerRef.current);
      }
    };
  }, [useFallback, endpointId]);

  return { status, lastMessage, useFallback };
}
```

### 3. Connection Status Indicator (`components/layout/ConnectionStatus.tsx`)

```typescript
interface ConnectionStatusProps {
  status: ConnectionStatus;
  useFallback: boolean;
}

export function ConnectionStatus({ status, useFallback }: ConnectionStatusProps) {
  const config = {
    connected: {
      color: 'bg-green-500',
      text: 'Connected',
      icon: Wifi,
    },
    connecting: {
      color: 'bg-yellow-500 animate-pulse',
      text: 'Connecting...',
      icon: Loader,
    },
    disconnected: {
      color: 'bg-gray-500',
      text: 'Disconnected',
      icon: WifiOff,
    },
    error: {
      color: 'bg-red-500',
      text: 'Connection Error',
      icon: AlertCircle,
    },
  };

  const { color, text, icon: Icon } = config[status] || config.disconnected;

  return (
    <div className="flex items-center gap-2 px-3 py-1.5 rounded-full bg-surface border border-border">
      <div className={`w-2 h-2 rounded-full ${color}`} />
      <Icon className="w-4 h-4 text-text-secondary" />
      <span className="text-sm text-text-secondary">
        {text}
        {useFallback && ' (Polling)'}
      </span>
    </div>
  );
}
```

### 4. Request List with Real-time Updates (`components/request/RequestList.tsx`)

```typescript
export function RequestList({ endpointId }: { endpointId: string | null }) {
  const { requests, loading, addRequest } = useRequests(endpointId);
  const { status, lastMessage, useFallback } = useWebSocket(endpointId);
  const [highlightedId, setHighlightedId] = useState<number | null>(null);

  // Handle incoming WebSocket messages
  useEffect(() => {
    if (!lastMessage) return;

    if (lastMessage.type === 'new_request') {
      const newRequest = lastMessage.data as Request;
      addRequest(newRequest);

      // Highlight new request
      setHighlightedId(newRequest.id);
      setTimeout(() => setHighlightedId(null), 2000);
    }
  }, [lastMessage, addRequest]);

  return (
    <div className="flex flex-col h-full">
      <div className="flex items-center justify-between p-4 border-b border-border">
        <h2 className="text-lg font-semibold">Requests</h2>
        <ConnectionStatus status={status} useFallback={useFallback} />
      </div>

      <div className="flex-1 overflow-y-auto">
        {loading && <LoadingState />}
        {!loading && requests.length === 0 && (
          <EmptyState
            icon={<Inbox className="w-12 h-12" />}
            title="No requests yet"
            description="Waiting for incoming webhooks..."
          />
        )}
        {requests.map((request) => (
          <RequestItem
            key={request.id}
            request={request}
            highlighted={highlightedId === request.id}
          />
        ))}
      </div>
    </div>
  );
}
```

### 5. Highlighted Request Item (`components/request/RequestItem.tsx`)

```typescript
interface RequestItemProps {
  request: Request;
  highlighted?: boolean;
  onClick?: () => void;
}

export function RequestItem({ request, highlighted, onClick }: RequestItemProps) {
  return (
    <div
      className={cn(
        'p-4 border-b border-border cursor-pointer transition-all',
        'hover:bg-surface-hover',
        highlighted && 'bg-accent-blue/10 animate-pulse'
      )}
      onClick={onClick}
    >
      <div className="flex items-center gap-3">
        <MethodBadge method={request.method} />
        <div className="flex-1 min-w-0">
          <div className="text-sm font-medium text-text-primary truncate">
            {request.path}
          </div>
          <div className="text-xs text-text-secondary">
            {formatDistanceToNow(new Date(request.received_at), { addSuffix: true })}
          </div>
        </div>
        <ChevronRight className="w-4 h-4 text-text-tertiary" />
      </div>
    </div>
  );
}
```

### 6. Pulse Animation (in `index.css`)

```css
@keyframes pulse-highlight {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.6;
  }
}

.animate-pulse {
  animation: pulse-highlight 1s cubic-bezier(0.4, 0, 0.6, 1) 2;
}
```

## Dependencies

### Blocking Dependencies
- [ ] Task 003: API Client & Type Definitions (for WebSocketClient base)
- [ ] Task 005: Endpoint Sidebar & Request List (for RequestList component)

### External Dependencies
- [ ] date-fns for timestamp formatting
  ```bash
  npm install date-fns
  ```
- [ ] lucide-react for icons (Wifi, WifiOff, Loader, AlertCircle)

## Effort Estimate

- **Size:** Medium (M)
- **Hours:** 8-10 hours
- **Parallel:** false (depends on Tasks 003 and 005)

**Breakdown:**
- Enhanced WebSocket client: 2 hours
- Enhanced useWebSocket hook: 2 hours
- HTTP polling fallback: 1.5 hours
- Connection status indicator: 1 hour
- Request list integration: 1.5 hours
- Pulse animation: 0.5 hours
- Testing (disconnect, reconnect, fallback): 2 hours
- Edge case handling: 1 hour

## Definition of Done

- [ ] WebSocket connects and receives messages in real-time
- [ ] Auto-reconnect tested (kill network, verify reconnect)
- [ ] Exponential backoff verified (logs show 1s, 2s, 4s delays)
- [ ] Connection status indicator updates correctly
- [ ] HTTP polling fallback activates after 3 failed attempts
- [ ] New requests pulse/highlight for 2 seconds
- [ ] Switching endpoints cleanly disconnects old connection
- [ ] No duplicate requests appear in list
- [ ] No memory leaks (disconnect cleans up timers)
- [ ] Code is TypeScript strict mode compliant
- [ ] No console errors or warnings

## Notes

- Test with Chrome DevTools: Network â†’ Offline to simulate disconnect
- Use `chrome://inspect/#devices` to debug WebSocket frames
- Consider adding "Last updated" timestamp to connection status
- Add reconnect button for manual reconnection attempt
- Consider rate limiting on backend (prevent message flooding)
- Test with high-frequency webhooks (>10 per second)
- Add option to disable auto-scroll when user is scrolling manually

## References

- WebSocket API: https://developer.mozilla.org/en-US/docs/Web/API/WebSocket
- Reconnection patterns: https://engineering.udacity.com/handling-websocket-reconnections-5e6168494969
- date-fns: https://date-fns.org/docs/Getting-Started
