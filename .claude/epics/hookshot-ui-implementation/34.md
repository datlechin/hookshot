---
name: Testing, Documentation & Deployment
status: completed
created: 2026-01-30T08:03:38Z
updated: 2026-01-31T08:43:00Z
github: https://github.com/datlechin/hookshot/issues/34
depends_on: [33]
parallel: false
conflicts_with: []
---

# Task: Testing, Documentation & Deployment

## Description

Implement comprehensive test coverage (unit, integration), perform accessibility audits, create developer documentation, and integrate the frontend build with the Rust backend for single-binary deployment. This is the final task that ensures production readiness.

**Scope:**
- Unit tests for components and hooks with Vitest
- Integration tests for API client and WebSocket with MSW
- Accessibility audit with axe-core and Lighthouse
- README with setup instructions and architecture
- Integration with Rust backend (embed build in binary)
- CI/CD pipeline configuration
- Production deployment checklist

## Acceptance Criteria

- [ ] Unit test coverage >80% for components and hooks
- [ ] All API endpoints mocked with MSW for testing
- [ ] WebSocket connection tested with mock server
- [ ] Accessibility score >95 in Lighthouse
- [ ] No axe-core violations on main pages
- [ ] README documents setup, development, and build process
- [ ] Frontend build embedded in Rust binary successfully
- [ ] CI/CD pipeline runs tests and builds on PR
- [ ] Production build serves from Rust backend
- [ ] Deployment checklist completed

## Technical Details

### 1. Unit Testing with Vitest

**Install Testing Dependencies:**

```bash
npm install -D vitest @testing-library/react @testing-library/jest-dom @testing-library/user-event jsdom
```

**Vitest Configuration** (`vitest.config.ts`):

```typescript
import { defineConfig } from 'vitest/config';
import react from '@vitejs/plugin-react';
import path from 'path';

export default defineConfig({
  plugins: [react()],
  test: {
    globals: true,
    environment: 'jsdom',
    setupFiles: ['./src/test/setup.ts'],
    coverage: {
      provider: 'v8',
      reporter: ['text', 'json', 'html'],
      exclude: ['node_modules/', 'src/test/'],
    },
  },
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
    },
  },
});
```

**Test Setup** (`src/test/setup.ts`):

```typescript
import '@testing-library/jest-dom';
import { cleanup } from '@testing-library/react';
import { afterEach } from 'vitest';

afterEach(() => {
  cleanup();
});
```

**Example Component Test** (`src/components/endpoint/EndpointItem.test.tsx`):

```typescript
import { describe, it, expect, vi } from 'vitest';
import { render, screen, fireEvent } from '@testing-library/react';
import { EndpointItem } from './EndpointItem';
import { Endpoint } from '@/lib/types';

const mockEndpoint: Endpoint = {
  id: 'test-123',
  created_at: '2026-01-30T08:00:00Z',
  custom_response_enabled: false,
  max_requests: 100,
};

describe('EndpointItem', () => {
  it('renders endpoint ID', () => {
    render(<EndpointItem endpoint={mockEndpoint} />);
    expect(screen.getByText('/test-123')).toBeInTheDocument();
  });

  it('shows custom badge when enabled', () => {
    const customEndpoint = { ...mockEndpoint, custom_response_enabled: true };
    render(<EndpointItem endpoint={customEndpoint} />);
    expect(screen.getByText('Custom')).toBeInTheDocument();
  });

  it('calls onClick when clicked', () => {
    const onClick = vi.fn();
    render(<EndpointItem endpoint={mockEndpoint} onClick={onClick} />);
    fireEvent.click(screen.getByText('/test-123'));
    expect(onClick).toHaveBeenCalledTimes(1);
  });
});
```

**Example Hook Test** (`src/hooks/useEndpoints.test.ts`):

```typescript
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { renderHook, waitFor } from '@testing-library/react';
import { useEndpoints } from './useEndpoints';
import { api } from '@/lib/api';

vi.mock('@/lib/api');

describe('useEndpoints', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it('loads endpoints on mount', async () => {
    const mockEndpoints = [
      { id: '1', created_at: '2026-01-30T08:00:00Z', custom_response_enabled: false, max_requests: 100 },
    ];
    vi.mocked(api.endpoints.list).mockResolvedValue(mockEndpoints);

    const { result } = renderHook(() => useEndpoints());

    expect(result.current.loading).toBe(true);

    await waitFor(() => {
      expect(result.current.loading).toBe(false);
    });

    expect(result.current.endpoints).toEqual(mockEndpoints);
  });

  it('handles errors', async () => {
    const error = new Error('Network error');
    vi.mocked(api.endpoints.list).mockRejectedValue(error);

    const { result } = renderHook(() => useEndpoints());

    await waitFor(() => {
      expect(result.current.error).toBeTruthy();
    });
  });
});
```

### 2. Integration Testing with MSW

**Install MSW:**

```bash
npm install -D msw
```

**MSW Setup** (`src/test/mocks/server.ts`):

```typescript
import { setupServer } from 'msw/node';
import { handlers } from './handlers';

export const server = setupServer(...handlers);

// Start server before all tests
beforeAll(() => server.listen({ onUnhandledRequest: 'error' }));

// Reset handlers after each test
afterEach(() => server.resetHandlers());

// Clean up after all tests
afterAll(() => server.close());
```

**MSW Handlers** (`src/test/mocks/handlers.ts`):

```typescript
import { http, HttpResponse } from 'msw';
import { Endpoint, Request } from '@/lib/types';

const mockEndpoints: Endpoint[] = [
  {
    id: 'abc123',
    created_at: '2026-01-30T08:00:00Z',
    custom_response_enabled: false,
    max_requests: 100,
  },
];

const mockRequests: Request[] = [
  {
    id: 1,
    endpoint_id: 'abc123',
    method: 'POST',
    path: '/webhook/abc123',
    headers: { 'Content-Type': 'application/json' },
    body: '{"test": true}',
    content_type: 'application/json',
    received_at: '2026-01-30T08:01:00Z',
    ip_address: '127.0.0.1',
  },
];

export const handlers = [
  http.get('/api/endpoints', () => {
    return HttpResponse.json(mockEndpoints);
  }),

  http.post('/api/endpoints', () => {
    const newEndpoint: Endpoint = {
      id: 'new-endpoint',
      created_at: new Date().toISOString(),
      custom_response_enabled: false,
      max_requests: 100,
    };
    return HttpResponse.json(newEndpoint);
  }),

  http.get('/api/endpoints/:id/requests', ({ params }) => {
    return HttpResponse.json(mockRequests);
  }),

  http.delete('/api/endpoints/:id', () => {
    return new HttpResponse(null, { status: 204 });
  }),
];
```

**WebSocket Mock** (`src/test/mocks/websocket.ts`):

```typescript
import { vi } from 'vitest';

export class MockWebSocket {
  static instances: MockWebSocket[] = [];

  onopen: (() => void) | null = null;
  onmessage: ((event: MessageEvent) => void) | null = null;
  onerror: ((event: Event) => void) | null = null;
  onclose: (() => void) | null = null;
  readyState = WebSocket.CONNECTING;

  constructor(public url: string) {
    MockWebSocket.instances.push(this);
    setTimeout(() => this.simulateOpen(), 100);
  }

  send(data: string) {
    // Mock send
  }

  close() {
    this.readyState = WebSocket.CLOSED;
    this.onclose?.();
  }

  simulateOpen() {
    this.readyState = WebSocket.OPEN;
    this.onopen?.();
  }

  simulateMessage(data: any) {
    const event = new MessageEvent('message', {
      data: JSON.stringify(data),
    });
    this.onmessage?.(event);
  }
}

// Replace global WebSocket with mock
global.WebSocket = MockWebSocket as any;
```

### 3. Accessibility Testing

**Install axe-core:**

```bash
npm install -D @axe-core/react
```

**Add to Development** (`src/main.tsx`):

```typescript
if (import.meta.env.DEV) {
  import('@axe-core/react').then((axe) => {
    axe.default(React, ReactDOM, 1000);
  });
}
```

**Accessibility Test Example:**

```typescript
import { describe, it, expect } from 'vitest';
import { render } from '@testing-library/react';
import { axe, toHaveNoViolations } from 'jest-axe';
import { EndpointSidebar } from './EndpointSidebar';

expect.extend(toHaveNoViolations);

describe('EndpointSidebar Accessibility', () => {
  it('should not have accessibility violations', async () => {
    const { container } = render(<EndpointSidebar />);
    const results = await axe(container);
    expect(results).toHaveNoViolations();
  });
});
```

### 4. Documentation

**README.md Template:**

```markdown
# Hookshot Frontend

Modern, responsive UI for Hookshot webhook testing tool.

## Features

- ðŸ“¡ Real-time webhook capture with WebSocket
- ðŸŽ¨ Beautiful dark/light mode interface
- ðŸ” Advanced request inspection (headers, body, metadata)
- âš™ï¸ Custom response configuration
- ðŸ“¤ Export to JSON, cURL, HTTP raw format
- ðŸ“± Fully responsive (mobile, tablet, desktop)

## Tech Stack

- **Framework:** React 18 + TypeScript
- **Build Tool:** Vite
- **UI Library:** shadcn/ui + Tailwind CSS
- **State Management:** React Hooks
- **Testing:** Vitest + Testing Library
- **Real-time:** WebSocket API

## Development Setup

### Prerequisites

- Node.js 18+
- npm or pnpm

### Installation

\`\`\`bash
cd frontend
npm install
\`\`\`

### Development

\`\`\`bash
npm run dev
\`\`\`

Open http://localhost:5173

### Testing

\`\`\`bash
# Run tests
npm run test

# Watch mode
npm run test:watch

# Coverage report
npm run test:coverage
\`\`\`

### Build

\`\`\`bash
npm run build
\`\`\`

Output in `dist/` directory.

## Architecture

\`\`\`
src/
â”œâ”€â”€ components/
â”‚   â”œâ”€â”€ layout/        # Header, Sidebar, etc.
â”‚   â”œâ”€â”€ endpoint/      # Endpoint components
â”‚   â”œâ”€â”€ request/       # Request list components
â”‚   â”œâ”€â”€ detail/        # Detail panel components
â”‚   â””â”€â”€ ui/            # shadcn/ui components
â”œâ”€â”€ hooks/             # Custom React hooks
â”œâ”€â”€ lib/
â”‚   â”œâ”€â”€ api.ts         # REST API client
â”‚   â”œâ”€â”€ websocket.ts   # WebSocket client
â”‚   â”œâ”€â”€ types.ts       # TypeScript types
â”‚   â””â”€â”€ utils.ts       # Utilities
â”œâ”€â”€ App.tsx            # Root component
â””â”€â”€ main.tsx           # Entry point
\`\`\`

## Environment Variables

Create `.env.local`:

\`\`\`
VITE_API_URL=http://localhost:3000
\`\`\`

## Integration with Backend

The frontend build is embedded in the Rust binary. See main README for deployment.

## Contributing

1. Fork the repository
2. Create a feature branch
3. Make changes with tests
4. Run `npm run test` and `npm run build`
5. Submit a pull request

## License

MIT
```

### 5. Rust Backend Integration

**Embed Frontend in Rust** (`src/main.rs`):

```rust
use axum::{
    Router,
    routing::get,
    http::StatusCode,
    response::{Html, IntoResponse},
};
use rust_embed::RustEmbed;

#[derive(RustEmbed)]
#[folder = "frontend/dist"]
struct Assets;

async fn static_handler(uri: axum::http::Uri) -> impl IntoResponse {
    let path = uri.path().trim_start_matches('/');

    // Try to serve the file
    if let Some(content) = Assets::get(path) {
        let mime = mime_guess::from_path(path).first_or_octet_stream();
        return (
            StatusCode::OK,
            [(axum::http::header::CONTENT_TYPE, mime.as_ref())],
            content.data.into_owned(),
        ).into_response();
    }

    // Fallback to index.html for SPA routing
    if let Some(index) = Assets::get("index.html") {
        return (
            StatusCode::OK,
            [(axum::http::header::CONTENT_TYPE, "text/html")],
            index.data.into_owned(),
        ).into_response();
    }

    StatusCode::NOT_FOUND.into_response()
}

#[tokio::main]
async fn main() {
    let app = Router::new()
        .nest("/api", api_routes())
        .fallback(static_handler);

    let listener = tokio::net::TcpListener::bind("0.0.0.0:3000")
        .await
        .unwrap();

    axum::serve(listener, app).await.unwrap();
}
```

**Update Cargo.toml:**

```toml
[dependencies]
rust-embed = "8.0"
mime_guess = "2.0"
```

**Build Script:**

```bash
#!/bin/bash
# build.sh

echo "Building frontend..."
cd frontend
npm install
npm run build

echo "Building Rust backend..."
cd ..
cargo build --release

echo "Done! Binary at target/release/hookshot"
```

### 6. CI/CD Pipeline

**GitHub Actions** (`.github/workflows/ci.yml`):

```yaml
name: CI

on:
  pull_request:
  push:
    branches: [main]

jobs:
  frontend:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
        with:
          node-version: 18
      - name: Install dependencies
        run: cd frontend && npm ci
      - name: Run tests
        run: cd frontend && npm run test
      - name: Build
        run: cd frontend && npm run build
      - name: Upload coverage
        uses: codecov/codecov-action@v3

  backend:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: dtolnay/rust-toolchain@stable
      - name: Build frontend
        run: cd frontend && npm ci && npm run build
      - name: Build backend
        run: cargo build --release
      - name: Run tests
        run: cargo test
```

### 7. Production Deployment Checklist

- [ ] Environment variables configured
- [ ] CORS configured for production domain
- [ ] HTTPS enabled (recommended)
- [ ] WebSocket URL uses wss:// (if HTTPS)
- [ ] Error tracking configured (Sentry, etc.)
- [ ] Analytics configured (optional)
- [ ] Performance monitoring enabled
- [ ] Backup strategy in place
- [ ] Domain configured
- [ ] SSL certificate valid
- [ ] Firewall rules configured
- [ ] Health check endpoint works

## Dependencies

### Blocking Dependencies
- [ ] Task 009: Performance Optimization & Polish (all UI complete)
- [ ] Backend API fully implemented

### External Dependencies
- [ ] Vitest and Testing Library
  ```bash
  npm install -D vitest @testing-library/react @testing-library/jest-dom @testing-library/user-event jsdom
  ```
- [ ] MSW for API mocking
  ```bash
  npm install -D msw
  ```
- [ ] axe-core for accessibility
  ```bash
  npm install -D @axe-core/react jest-axe
  ```

## Effort Estimate

- **Size:** Large (L)
- **Hours:** 10-12 hours
- **Parallel:** false (final task)

**Breakdown:**
- Unit tests: 3 hours
- Integration tests with MSW: 2 hours
- Accessibility testing: 1 hour
- Documentation (README): 1.5 hours
- Rust integration: 2 hours
- CI/CD setup: 1 hour
- Production deployment: 1.5 hours

## Definition of Done

- [ ] Test coverage >80%
- [ ] All API endpoints mocked and tested
- [ ] WebSocket tested with mock
- [ ] Accessibility score >95
- [ ] README complete with setup instructions
- [ ] Frontend embedded in Rust binary
- [ ] CI/CD pipeline runs successfully
- [ ] Production build tested locally
- [ ] Deployment checklist completed
- [ ] No failing tests
- [ ] No console errors in production

## Notes

- Use `npm run test:coverage` to check coverage
- Test production build locally: `npm run build && npm run preview`
- Verify embedded assets work: `cargo run --release`
- Consider adding E2E tests with Playwright (future enhancement)
- Add performance budgets to CI (future enhancement)
- Consider adding visual regression tests (future enhancement)

## References

- Vitest: https://vitest.dev/guide/
- Testing Library: https://testing-library.com/docs/react-testing-library/intro
- MSW: https://mswjs.io/docs/
- axe-core: https://github.com/dequelabs/axe-core
- rust-embed: https://github.com/pyrossh/rust-embed
