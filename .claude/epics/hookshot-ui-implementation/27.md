---
name: API Client & Type Definitions
status: completed
created: 2026-01-30T08:03:38Z
updated: 2026-01-30T09:08:50Z
github: https://github.com/datlechin/hookshot/issues/27
depends_on: [25]
parallel: true
conflicts_with: []
---

# Task: API Client & Type Definitions

## Description

Implement the complete API integration layer including TypeScript types, REST API client, WebSocket client, and custom React hooks. This provides the data layer for the entire application and ensures type safety across frontend-backend communication.

**Scope:**
- Define TypeScript interfaces matching backend schema (Endpoint, Request, Config)
- Implement typed REST API client with error handling
- Implement WebSocket client with auto-reconnect and fallback
- Create custom hooks: useEndpoints, useRequests, useWebSocket, useLocalStorage
- Set up error handling and retry logic
- Create mock data for development

## Acceptance Criteria

- [ ] All TypeScript types defined and exported from `lib/types.ts`
- [ ] REST API client implemented with GET, POST, PUT, DELETE methods
- [ ] API client has centralized error handling
- [ ] WebSocket client connects and auto-reconnects on disconnect
- [ ] Exponential backoff implemented (1s, 2s, 4s, 8s, max 30s)
- [ ] HTTP polling fallback works when WebSocket unavailable
- [ ] useEndpoints hook fetches and manages endpoints
- [ ] useRequests hook fetches requests for an endpoint
- [ ] useWebSocket hook manages WebSocket connection lifecycle
- [ ] useLocalStorage hook syncs state with localStorage
- [ ] Mock data available for development without backend

## Technical Details

### 1. TypeScript Types (`lib/types.ts`)

```typescript
// Endpoint entity
export interface Endpoint {
  id: string;
  created_at: string;
  custom_response_enabled: boolean;
  response_status?: number;
  response_headers?: Record<string, string>;
  response_body?: string;
  forward_url?: string;
  max_requests: number;
}

// Request entity
export interface Request {
  id: number;
  endpoint_id: string;
  method: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH' | 'HEAD' | 'OPTIONS';
  path: string;
  query_string?: string;
  headers: Record<string, string>;
  body?: string;
  content_type?: string;
  received_at: string;
  ip_address: string;
}

// Config for custom response
export interface EndpointConfig {
  custom_response_enabled: boolean;
  response_status?: number;
  response_headers?: Record<string, string>;
  response_body?: string;
}

// WebSocket message
export interface WebSocketMessage {
  type: 'new_request' | 'endpoint_updated' | 'error';
  data: Request | Endpoint | { message: string };
}

// API Error
export class ApiError extends Error {
  constructor(
    public status: number,
    public statusText: string,
    public data?: unknown
  ) {
    super(`API Error: ${status} ${statusText}`);
  }
}
```

### 2. REST API Client (`lib/api.ts`)

```typescript
const API_BASE = import.meta.env.VITE_API_URL || '';

async function request<T>(
  endpoint: string,
  options?: RequestInit
): Promise<T> {
  const response = await fetch(`${API_BASE}${endpoint}`, {
    ...options,
    headers: {
      'Content-Type': 'application/json',
      ...options?.headers,
    },
  });

  if (!response.ok) {
    throw new ApiError(response.status, response.statusText);
  }

  return response.json();
}

export const api = {
  endpoints: {
    list: () => request<Endpoint[]>('/api/endpoints'),
    create: () => request<Endpoint>('/api/endpoints', { method: 'POST' }),
    delete: (id: string) =>
      request<void>(`/api/endpoints/${id}`, { method: 'DELETE' }),
    updateConfig: (id: string, config: EndpointConfig) =>
      request<Endpoint>(`/api/endpoints/${id}/config`, {
        method: 'PUT',
        body: JSON.stringify(config),
      }),
  },
  requests: {
    list: (endpointId: string) =>
      request<Request[]>(`/api/endpoints/${endpointId}/requests`),
    delete: (id: number) =>
      request<void>(`/api/requests/${id}`, { method: 'DELETE' }),
    clear: (endpointId: string) =>
      request<void>(`/api/endpoints/${endpointId}/requests`, {
        method: 'DELETE',
      }),
  },
};
```

### 3. WebSocket Client (`lib/websocket.ts`)

```typescript
export class WebSocketClient {
  private ws: WebSocket | null = null;
  private reconnectAttempts = 0;
  private maxReconnectDelay = 30000;
  private reconnectTimer?: number;

  constructor(private url: string) {}

  connect(onMessage: (msg: WebSocketMessage) => void) {
    this.ws = new WebSocket(this.url);

    this.ws.onopen = () => {
      this.reconnectAttempts = 0;
    };

    this.ws.onmessage = (event) => {
      const message: WebSocketMessage = JSON.parse(event.data);
      onMessage(message);
    };

    this.ws.onerror = () => {
      // Auto-reconnect on error
      this.reconnect(onMessage);
    };

    this.ws.onclose = () => {
      this.reconnect(onMessage);
    };
  }

  private reconnect(onMessage: (msg: WebSocketMessage) => void) {
    const delay = Math.min(
      1000 * Math.pow(2, this.reconnectAttempts),
      this.maxReconnectDelay
    );

    this.reconnectTimer = window.setTimeout(() => {
      this.reconnectAttempts++;
      this.connect(onMessage);
    }, delay);
  }

  disconnect() {
    if (this.reconnectTimer) {
      clearTimeout(this.reconnectTimer);
    }
    if (this.ws) {
      this.ws.close();
      this.ws = null;
    }
  }

  send(data: unknown) {
    if (this.ws?.readyState === WebSocket.OPEN) {
      this.ws.send(JSON.stringify(data));
    }
  }
}
```

### 4. Custom Hooks

**useEndpoints** (`hooks/useEndpoints.ts`)
```typescript
export function useEndpoints() {
  const [endpoints, setEndpoints] = useState<Endpoint[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);

  useEffect(() => {
    loadEndpoints();
  }, []);

  async function loadEndpoints() {
    setLoading(true);
    try {
      const data = await api.endpoints.list();
      setEndpoints(data);
      setError(null);
    } catch (err) {
      setError(err as Error);
    } finally {
      setLoading(false);
    }
  }

  async function createEndpoint() {
    const endpoint = await api.endpoints.create();
    setEndpoints(prev => [...prev, endpoint]);
    return endpoint;
  }

  async function deleteEndpoint(id: string) {
    await api.endpoints.delete(id);
    setEndpoints(prev => prev.filter(e => e.id !== id));
  }

  return { endpoints, loading, error, createEndpoint, deleteEndpoint, reload: loadEndpoints };
}
```

**useRequests** (`hooks/useRequests.ts`)
```typescript
export function useRequests(endpointId: string | null) {
  const [requests, setRequests] = useState<Request[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);

  useEffect(() => {
    if (!endpointId) return;
    loadRequests();
  }, [endpointId]);

  async function loadRequests() {
    if (!endpointId) return;
    setLoading(true);
    try {
      const data = await api.requests.list(endpointId);
      setRequests(data);
      setError(null);
    } catch (err) {
      setError(err as Error);
    } finally {
      setLoading(false);
    }
  }

  async function clearRequests() {
    if (!endpointId) return;
    await api.requests.clear(endpointId);
    setRequests([]);
  }

  function addRequest(request: Request) {
    setRequests(prev => [request, ...prev]);
  }

  return { requests, loading, error, clearRequests, addRequest, reload: loadRequests };
}
```

**useWebSocket** (`hooks/useWebSocket.ts`)
```typescript
export function useWebSocket(endpointId: string | null) {
  const [connected, setConnected] = useState(false);
  const [lastMessage, setLastMessage] = useState<WebSocketMessage | null>(null);
  const clientRef = useRef<WebSocketClient | null>(null);

  useEffect(() => {
    if (!endpointId) return;

    const wsUrl = `${location.protocol === 'https:' ? 'wss:' : 'ws:'}//${location.host}/api/ws/${endpointId}`;
    const client = new WebSocketClient(wsUrl);

    client.connect((message) => {
      setLastMessage(message);
      setConnected(true);
    });

    clientRef.current = client;

    return () => {
      client.disconnect();
      setConnected(false);
    };
  }, [endpointId]);

  return { connected, lastMessage };
}
```

**useLocalStorage** (`hooks/useLocalStorage.ts`)
```typescript
export function useLocalStorage<T>(key: string, initialValue: T) {
  const [value, setValue] = useState<T>(() => {
    try {
      const item = localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch {
      return initialValue;
    }
  });

  useEffect(() => {
    localStorage.setItem(key, JSON.stringify(value));
  }, [key, value]);

  return [value, setValue] as const;
}
```

### 5. Mock Data (`lib/mock.ts`)

```typescript
export const mockEndpoints: Endpoint[] = [
  {
    id: 'a1b2c3d4',
    created_at: '2026-01-30T08:00:00Z',
    custom_response_enabled: false,
    max_requests: 100,
  },
];

export const mockRequests: Request[] = [
  {
    id: 1,
    endpoint_id: 'a1b2c3d4',
    method: 'POST',
    path: '/webhook/a1b2c3d4',
    headers: { 'Content-Type': 'application/json' },
    body: '{"event": "test"}',
    content_type: 'application/json',
    received_at: '2026-01-30T08:01:00Z',
    ip_address: '127.0.0.1',
  },
];
```

## Dependencies

### Blocking Dependencies
- [ ] Task 001: Project Setup & Infrastructure (for TypeScript config)
- [ ] Backend API contract documented (types must match)

### External Dependencies
None - uses native Fetch API and WebSocket API

## Effort Estimate

- **Size:** Medium (M)
- **Hours:** 8-10 hours
- **Parallel:** true (can work alongside Task 002)

**Breakdown:**
- TypeScript types: 1 hour
- REST API client: 2 hours
- WebSocket client: 2 hours
- useEndpoints hook: 1 hour
- useRequests hook: 1 hour
- useWebSocket hook: 1.5 hours
- useLocalStorage hook: 0.5 hours
- Mock data: 0.5 hours
- Testing: 1.5 hours

## Definition of Done

- [ ] All types compile without TypeScript errors
- [ ] API client successfully calls mock backend or returns mock data
- [ ] WebSocket client connects (or gracefully handles no backend)
- [ ] Auto-reconnect tested (disconnect network, verify reconnect)
- [ ] All hooks tested with React Testing Library
- [ ] Error handling tested (network errors, 404, 500, etc.)
- [ ] Mock data renders in UI components
- [ ] Code documented with JSDoc comments
- [ ] No console errors in development mode

## Notes

- Consider using SWR or React Query for caching (future optimization)
- Add request/response interceptors for logging in development
- Environment variable `VITE_API_URL` should default to same origin
- WebSocket URL construction should handle http/https â†’ ws/wss
- Test with Chrome DevTools Network tab throttling (slow 3G)
- Consider adding request timeout (default 30s)

## References

- Fetch API: https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API
- WebSocket API: https://developer.mozilla.org/en-US/docs/Web/API/WebSocket
- React Hooks: https://react.dev/reference/react
